# APITestSuite 学习文档

## 📚 目录

1. [框架概述](#框架概述)
2. [架构设计](#架构设计)
3. [核心概念](#核心概念)
4. [快速开始](#快速开始)
5. [配置详解](#配置详解)
6. [测试用例编写](#测试用例编写)
7. [工作流程](#工作流程)
8. [报告解读](#报告解读)
9. [高级功能](#高级功能)
10. [常见问题](#常见问题)
11. [扩展开发](#扩展开发)

---

## 框架概述

### 什么是 APITestSuite？

APITestSuite 是一个**自动化的API测试框架**，专门用于测试基于Go语言protobuf定义的微服务API接口。

### 核心特性

- ✅ **自动解析**: 从proto文件自动解析API接口定义
- ✅ **代码生成**: 自动生成Python测试代码
- ✅ **多服务支持**: 支持多个微服务（Hall、Room、Social等）
- ✅ **真实调用**: 直接连接服务器进行真实API调用
- ✅ **完整报告**: 生成HTML和Excel测试报告
- ✅ **接口变更检测**: 自动检测新增/修改/删除的接口

### 适用场景

- 微服务API接口测试
- 基于protobuf定义的接口
- 需要自动化测试的场景
- 需要生成测试报告的场景

---

## 架构设计

### 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    APITestSuite 框架                     │
└─────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
        ▼                   ▼                   ▼
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│  Git更新器    │   │  Proto解析器  │   │  连接测试器   │
│ GitUpdater   │   │ ProtobufParser│  │ConnectionTester│
└──────────────┘   └──────────────┘   └──────────────┘
        │                   │                   │
        └───────────────────┼───────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────┐
        │        测试代码生成器              │
        │      TestGenerator                │
        └───────────────────────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────┐
        │         API客户端                  │
        │      APIClient                    │
        │  (TCP客户端 + Protobuf序列化)      │
        └───────────────────────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────┐
        │        测试运行器                  │
        │      TestRunner                   │
        └───────────────────────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────┐
        │        报告生成器                  │
        │      ReportGenerator              │
        │  (HTML + Excel)                   │
        └───────────────────────────────────┘
```

### 核心模块

#### 1. GitUpdater（Git更新器）
- **功能**: 自动拉取和更新服务器代码仓库
- **位置**: `framework/git_updater.py`
- **主要方法**:
  - `check_and_update()`: 检查并更新仓库
  - `_clone_repo()`: 克隆仓库
  - `_pull_update()`: 拉取更新
  - `_update_submodules()`: 更新子模块

#### 2. ProtobufParser（Proto解析器）
- **功能**: 从proto文件解析API接口定义
- **位置**: `framework/protobuf_parser.py`
- **主要方法**:
  - `discover_interfaces()`: 发现所有服务的接口
  - `_parse_proto_file()`: 解析proto文件
  - `_normalize_method_name()`: 标准化方法名

#### 3. TestGenerator（测试代码生成器）
- **功能**: 根据接口定义和测试用例生成Python测试代码
- **位置**: `framework/test_generator.py`
- **主要方法**:
  - `generate_all_tests()`: 生成所有服务的测试代码
  - `_write_test_file()`: 写入测试文件
  - `_load_test_cases()`: 加载YAML测试用例

#### 4. APIClient（API客户端）
- **功能**: 处理与服务器的通信（TCP + Protobuf）
- **位置**: `framework/client.py`
- **主要方法**:
  - `login()`: 登录获取token
  - `call_rpc()`: 调用RPC接口
  - `_encode_request_body()`: 编码请求body
  - `_parse_response_body()`: 解析响应body

#### 5. TestRunner（测试运行器）
- **功能**: 运行测试并收集结果
- **位置**: `framework/test_runner.py`
- **主要方法**:
  - `run_all_tests()`: 运行所有测试
  - `_organize_results_by_service()`: 按服务组织结果
  - `_get_problem_analysis()`: 生成问题分析

#### 6. ReportGenerator（报告生成器）
- **功能**: 生成HTML和Excel测试报告
- **位置**: `framework/report_generator.py`
- **主要方法**:
  - `generate_report()`: 生成报告
  - `_generate_html()`: 生成HTML报告
  - `_generate_excel()`: 生成Excel报告

---

## 核心概念

### 1. 服务（Service）

服务是指一个独立的微服务，例如：
- **Hall服务**: 处理用户信息、物品管理等
- **Room服务**: 处理房间、队伍、匹配等
- **Social服务**: 处理聊天、好友、消息等

每个服务有独立的proto文件定义接口。

### 2. 接口（Interface）

接口是指一个具体的API方法，例如：
- `FetchSelfFullUserInfo`: 获取自己的完整用户信息
- `CreateTeam`: 创建队伍
- `SendMessage`: 发送消息

每个接口对应proto文件中的一个Req/Rsp消息对。

### 3. 测试用例（Test Case）

测试用例定义在YAML文件中，包含：
- **接口名称**: 要测试的接口
- **描述**: 接口的说明
- **请求参数**: 发送给服务器的参数

### 4. 请求/响应（Request/Response）

- **请求**: 发送给服务器的数据，包含所有字段和类型
- **响应**: 服务器返回的完整数据，包括：
  - `success`: 是否成功
  - `response`: 响应数据
  - `error_code`: 错误码
  - `error_message`: 错误信息

### 5. 前置条件（Precondition）

某些接口需要先满足条件才能测试，例如：
- 创建队伍前需要先登录
- 发送消息前需要先获取conv_id
- 加入队伍前需要先有队伍存在

---

## 快速开始

### 1. 安装依赖

```bash
pip install -r requirements.txt
```

### 2. 配置服务器

编辑 `config.yaml`:

```yaml
servers:
  gate:
    address: "47.84.190.150:29205"
  login:
    url: "http://47.84.190.150:29002"

jinn_server:
  repo_url: "https://git.17zjh.com/wegame/jinn_server.git"
  branch: "v0.1.0"

services:
  hall:
    proto_path: "jinn_server/config/proto_jinn/client"
```

### 3. 添加测试用例

创建 `test_cases/hall/test_hall.yaml`:

```yaml
test_cases:
  FetchSelfFullUserInfo:
    description: "获取自己的完整用户信息"
    request: {}
  UpdateNickname:
    description: "更新昵称"
    request:
      nickname: "TestNickname_123"
```

### 4. 运行测试

```bash
# 首次运行（自动拉取代码、解析接口、生成测试、执行测试、生成报告）
python3 main.py --run

# 跳过Git检查
python3 main.py --run --skip-git-check
```

### 5. 查看报告

- HTML报告: `reports/test_report_*.html`
- Excel报告: `reports/test_report.xlsx`

---

## 配置详解

### config.yaml 结构

```yaml
# 服务器连接配置
servers:
  gate:
    address: "IP:端口"        # Gate服务器地址（TCP协议）
  login:
    url: "http://IP:端口"      # Login服务器地址（HTTP协议）

# Git仓库配置
jinn_server:
  repo_url: "Git仓库地址"      # 服务器代码仓库
  branch: "分支名"              # 分支或版本标签
  local_path: "jinn_server"    # 本地存储路径
  read_only: true              # 是否只读

# 服务配置
services:
  hall:                        # 服务名称
    proto_path: "路径"         # proto文件路径（相对于jinn_server目录）
  room:
    proto_path: "路径"
  social:
    proto_path: "路径"

# 测试配置
test:
  output_dir: "generated_tests"  # 生成的测试代码目录
  report_dir: "reports"          # 报告输出目录
  timeout: 30                    # 请求超时时间（秒）
```

### 配置说明

#### servers（服务器配置）

- **gate.address**: Gate服务器地址，使用TCP协议
- **login.url**: Login服务器地址，使用HTTP协议

#### jinn_server（Git仓库配置）

- **repo_url**: 服务器代码的Git仓库地址
- **branch**: 要拉取的分支或版本标签
- **local_path**: 代码在本地存储的目录名
- **read_only**: 设置为true，框架不会修改代码

#### services（服务配置）

每个服务需要配置proto文件路径，框架会从这个路径下的`{service}_reqrsp.proto`文件解析接口。

#### test（测试配置）

- **output_dir**: 生成的Python测试代码存放目录
- **report_dir**: 测试报告存放目录
- **timeout**: API请求的超时时间

---

## 测试用例编写

### YAML格式

测试用例使用YAML格式，文件位置：`test_cases/{service}/test_{service}.yaml`

### 基本结构

```yaml
test_cases:
  接口名称:
    description: "接口描述"
    request:
      参数1: 值1
      参数2: 值2
```

### 示例

#### 示例1: 无参数接口

```yaml
test_cases:
  FetchSelfFullUserInfo:
    description: "获取自己的完整用户信息"
    request: {}
```

#### 示例2: 有参数接口

```yaml
test_cases:
  UpdateNickname:
    description: "更新昵称"
    request:
      nickname: "TestNickname_123"
```

#### 示例3: 复杂参数

```yaml
test_cases:
  SendMessage:
    description: "发送消息"
    request:
      to_uid: 0
      scene: 4
      scene_id: 0
      content:
        msg_type: 1
        text:
          text: "test message"
```

### 参数类型

- **字符串**: `nickname: "TestName"`
- **数字**: `target_uid: 10000263`
- **布尔值**: `ready: true`
- **列表**: `item_id_list: [1, 2, 3]`
- **对象**: `content: {msg_type: 1}`

### 注意事项

1. **参数名称**: 必须与proto文件中定义的字段名一致（小写下划线格式）
2. **参数类型**: 必须符合proto定义的类型
3. **必需参数**: proto中定义的必需字段必须提供
4. **可选参数**: 可选字段可以不提供

---

## 工作流程

### 完整执行流程

```
1. Git更新
   ├─ 检查仓库是否存在
   ├─ 不存在 → 克隆仓库
   └─ 存在 → 拉取最新代码
   
2. 连接测试
   ├─ 测试Gate服务器连接
   └─ 测试Login服务器连接
   
3. 解析接口
   ├─ 读取proto文件
   ├─ 解析消息定义
   └─ 提取接口列表
   
4. 生成测试代码
   ├─ 读取测试用例（YAML）
   ├─ 生成Python测试文件
   └─ 保存到generated_tests/
   
5. 执行测试（如果指定--run）
   ├─ 登录获取token
   ├─ 连接Gate服务器
   ├─ 执行每个测试用例
   ├─ 收集测试结果
   └─ 处理错误和失败
   
6. 生成报告（如果指定--run）
   ├─ 生成HTML报告
   ├─ 生成Excel报告
   └─ 保存到reports/
```

### 详细步骤说明

#### 步骤1: Git更新

```python
git_updater = GitUpdater(config)
git_updater.check_and_update()
```

- 如果仓库不存在，执行 `git clone`
- 如果仓库存在，执行 `git pull`
- 自动更新子模块

#### 步骤2: 解析接口

```python
parser = ProtobufParser(config)
interfaces = parser.discover_interfaces()
```

- 遍历配置的服务列表
- 读取每个服务的proto文件
- 解析 `message ServiceMethodReq` 定义
- 提取接口名称和消息类型

#### 步骤3: 生成测试代码

```python
generator = TestGenerator(config)
generator.generate_all_tests(interfaces)
```

- 为每个服务生成一个测试文件
- 为每个接口生成一个测试方法
- 从YAML加载测试用例参数
- 生成完整的测试代码

#### 步骤4: 执行测试

```python
runner = TestRunner(config)
results = runner.run_all_tests()
```

- 加载生成的测试文件
- 使用unittest框架运行
- 收集每个测试的结果
- 组织结果按服务分组

#### 步骤5: 生成报告

```python
generator = ReportGenerator(config)
generator.generate_report(results)
```

- 生成HTML报告（带时间戳）
- 生成Excel报告（固定文件名，覆盖）
- 清理旧报告（保留最新3个HTML）

---

## 报告解读

### HTML报告

#### 报告结构

```
API测试报告
├─ 统计信息
│  ├─ 总接口数
│  ├─ 通过数
│  └─ 失败数
│
└─ 服务详情（可折叠）
   ├─ Hall服务
   │  ├─ 接口1
   │  │  ├─ 请求参数（带类型）
   │  │  ├─ 完整响应
   │  │  ├─ 错误信息（如果有）
   │  │  └─ 问题分析（如果失败）
   │  └─ 接口2...
   ├─ Room服务...
   └─ Social服务...
```

#### 关键字段说明

- **请求**: 显示服务器协议定义的字段和类型，以及实际发送的值
  - 格式: `字段名(类型): 值`
  - 例如: `nickname(string): TestNickname_123`
  
- **响应**: 显示完整的服务器响应
  ```json
  {
    "success": true,
    "response": {
      "updatenickname": {
        "nickname": "TestNickname_123"
      }
    },
    "error_code": 200,
    "error_message": ""
  }
  ```

- **响应码**: 服务器返回的状态码
  - `200`: 成功
  - `其他`: 失败（会显示错误原因）

- **问题分析**: 失败时显示
  - 前置条件
  - 服务器报错
  - 可能存在的问题

### Excel报告

#### 列说明

| 列名 | 说明 |
|------|------|
| 接口名称 | 测试的接口名称 |
| 请求方法 | 协议类型（TCP/gRPC/HTTP） |
| 状态 | 通过/失败/错误 |
| 响应码 | 服务器返回的状态码 |
| 请求 | 请求参数的JSON格式 |
| 实际输出 | 完整服务器响应的JSON格式 |
| 错误信息 | 错误消息（如果有） |
| 问题分析 | 问题分析和建议（如果失败） |

#### 使用技巧

- **筛选**: 可以按状态、响应码筛选
- **排序**: 可以按接口名称、状态排序
- **查找**: 可以搜索特定接口或错误信息

---

## 高级功能

### 1. 前置条件处理

某些接口需要先满足条件才能测试，框架会自动处理：

#### 示例: 需要先创建队伍

```python
# 在setUpClass中自动创建队伍
@classmethod
def setUpClass(cls):
    # 创建队伍
    create_result = cls.client.call_rpc('Room', 'CreateTeam', {'game_mode': 1})
    # 提取team_id
    cls.team_id = create_result['response']['createteam']['team_info']['team_id']
```

#### 示例: 需要先发送消息

```python
# 在测试方法中先发送消息获取conv_id和seq
def test_add_reaction(self):
    # 前置：发送消息
    send_result = self.client.call_rpc('Social', 'SendMessage', {...})
    conv_id = send_result['response']['sendmessage']['conv_id']
    seq = send_result['response']['sendmessage']['seq']
    
    # 实际测试
    result = self.client.call_rpc('Social', 'AddReaction', {
        'conv_id': conv_id,
        'seq': seq,
        'reaction_id': 1
    })
```

### 2. 接口变更检测

框架可以检测接口的变更：

- **新增接口**: 新出现的接口
- **修改接口**: 参数或响应结构改变的接口
- **删除接口**: 不再存在的接口

变更信息会显示在报告中。

### 3. 错误分析

框架会自动分析错误原因：

- **参数错误**: 参数缺失、类型错误、值无效
- **服务器错误**: 服务不可用、内部错误
- **网络错误**: 连接失败、超时
- **业务错误**: team not exist、user not exist等

### 4. 自定义断言

可以在生成的测试代码中添加自定义断言：

```python
def test_updatenickname(self):
    result = self.client.call_rpc('Hall', 'UpdateNickname', {'nickname': 'Test'})
    
    # 自定义断言
    self.assertEqual(result['response']['updatenickname']['nickname'], 'Test')
    self.assertTrue(result['success'])
```

---

## 常见问题

### Q1: 如何添加新服务？

**A**: 
1. 在 `config.yaml` 的 `services` 部分添加服务配置
2. 创建 `test_cases/{service}/test_{service}.yaml` 文件
3. 运行 `python3 main.py` 自动生成测试代码

### Q2: 如何修改测试用例？

**A**: 
1. 编辑对应的YAML文件（`test_cases/{service}/test_{service}.yaml`）
2. 重新运行 `python3 main.py` 重新生成测试代码
3. 运行 `python3 main.py --run` 执行测试

### Q3: 测试失败怎么办？

**A**: 
1. 查看HTML或Excel报告中的"错误信息"和"问题分析"
2. 检查请求参数是否正确
3. 检查服务器是否正常运行
4. 检查前置条件是否满足

### Q4: 如何查看完整的请求和响应？

**A**: 
- HTML报告: 点击服务名称展开，查看每个接口的详细信息
- Excel报告: 查看"请求"和"实际输出"列
- 控制台: 运行测试时会打印请求和响应

### Q5: 如何跳过某些接口的测试？

**A**: 
在生成的测试代码中，可以添加 `skipTest`:

```python
def test_some_interface(self):
    self.skipTest("暂时跳过此接口")
```

### Q6: 如何添加自定义的测试逻辑？

**A**: 
1. 在生成的测试代码中直接修改
2. 注意：重新生成测试代码会覆盖修改
3. 建议：将自定义逻辑提取到框架中，或使用测试用例的扩展字段

### Q7: 报告中的"请求方法"为什么都是TCP？

**A**: 
当前系统使用TCP协议通过Gate服务器通信，不是HTTP REST API。如果某个接口使用HTTP，可以在代码中特殊处理。

### Q8: 如何修改报告格式？

**A**: 
- HTML报告: 修改 `framework/report_generator.py` 中的模板
- Excel报告: 修改 `_write_service_sheet()` 方法

---

## 扩展开发

### 添加新服务支持

#### 步骤1: 配置服务

在 `config.yaml` 中添加：

```yaml
services:
  newservice:
    proto_path: "jinn_server/config/proto_jinn/client"
```

#### 步骤2: 扩展ProtoParser

如果proto文件格式不同，可能需要修改 `protobuf_parser.py` 中的解析逻辑。

#### 步骤3: 扩展APIClient

在 `client.py` 中添加新服务的编码/解码逻辑：

```python
def _encode_newservice_body_req(self, method: str, request_data: Dict) -> bytes:
    # 实现新服务的请求编码
    pass

def _parse_newservice_body_rsp(self, method: str, body_bytes: bytes) -> Dict:
    # 实现新服务的响应解析
    pass
```

#### 步骤4: 添加测试用例

创建 `test_cases/newservice/test_newservice.yaml`

### 添加新的报告格式

#### 步骤1: 实现报告生成方法

在 `report_generator.py` 中添加：

```python
def _generate_json(self, test_results: Dict[str, Any]) -> str:
    """生成JSON报告"""
    import json
    json_path = os.path.join(self.report_dir, "test_report.json")
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(test_results, f, indent=2, ensure_ascii=False)
    return json_path
```

#### 步骤2: 在generate_report中调用

```python
def generate_report(self, test_results: Dict[str, Any]) -> str:
    # ... 现有代码 ...
    json_path = self._generate_json(test_results)
    return report_path
```

### 添加自定义断言

#### 方法1: 在测试用例YAML中添加断言

扩展YAML格式：

```yaml
test_cases:
  MethodName:
    description: "接口描述"
    request:
      param1: value1
    assertions:
      - field: "response.field1"
        operator: "equals"
        value: "expected_value"
```

#### 方法2: 在生成的测试代码中添加

修改 `test_generator.py` 中的代码生成逻辑，添加断言生成。

---

## 最佳实践

### 1. 测试用例组织

- 按服务分组：每个服务一个YAML文件
- 命名规范：使用 `test_{service}.yaml`
- 参数清晰：使用有意义的参数值

### 2. 错误处理

- 检查前置条件：确保依赖的接口先执行成功
- 处理边界情况：测试空值、最大值、最小值
- 验证响应：检查关键字段是否存在

### 3. 报告使用

- 定期查看报告：及时发现接口问题
- 关注失败接口：优先修复失败的接口
- 分析问题模式：找出常见错误原因

### 4. 代码维护

- 定期更新：保持框架和依赖最新
- 版本控制：使用Git管理测试用例
- 文档更新：及时更新测试用例说明

---

## 术语表

| 术语 | 说明 |
|------|------|
| Proto文件 | Protocol Buffers定义文件，描述接口结构 |
| Req/Rsp | Request/Response，请求和响应消息 |
| TCP | 传输控制协议，用于Gate服务器通信 |
| gRPC | Google的RPC框架 |
| Protobuf | Google的数据序列化格式 |
| 前置条件 | 执行测试前需要满足的条件 |
| 测试用例 | 定义接口测试的输入和预期输出 |
| 响应码 | 服务器返回的状态码（200表示成功） |

---

## 参考资料

- [Protocol Buffers官方文档](https://developers.google.com/protocol-buffers)
- [Python unittest文档](https://docs.python.org/3/library/unittest.html)
- [YAML语法指南](https://yaml.org/spec/)

---

## 总结

APITestSuite 提供了一个完整的API测试解决方案：

1. **自动化**: 从proto文件自动解析接口，自动生成测试代码
2. **真实**: 直接连接服务器进行真实API调用
3. **完整**: 生成详细的HTML和Excel报告
4. **灵活**: 支持自定义测试用例和扩展

通过本学习文档，你应该能够：
- ✅ 理解框架的架构和原理
- ✅ 配置和使用框架
- ✅ 编写测试用例
- ✅ 解读测试报告
- ✅ 扩展框架功能

如有问题，请参考"常见问题"部分或查看代码注释。

