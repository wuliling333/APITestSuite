# 五维度测试用例生成说明

## 功能概述

测试用例生成器可以按照**五维度**自动生成完整的接口测试用例，并输出为Excel格式。

## 五维度说明

### 1. 正常（正例）
- **目的**: 验证接口正常业务流程
- **优先级**: P0（高）
- **预期**: 接口调用成功，返回200状态码

### 2. 参数异常（5条高频反例）
- **必填参数缺失**: 缺少必需字段
- **参数类型错误**: 类型不匹配（如字符串传数字）
- **参数值为空**: 空字符串、0、null等
- **参数值超出范围**: 超出有效范围的值
- **参数格式错误**: 格式不符合要求的值
- **优先级**: P1（中）

### 3. 业务异常
- **目的**: 验证业务逻辑异常处理
- **场景**: 
  - 资源不存在（如用户不存在、队伍不存在）
  - 状态不正确（如队伍已解散）
  - 业务规则违反（如重复操作）
- **优先级**: P1（中）

### 4. 权限安全
- **未授权访问**: token缺失或无效
- **越权访问**: 无权限访问他人资源
- **优先级**: P0（高）

### 5. 性能边界
- **大数据量**: 测试大量数据处理能力
- **并发请求**: 并发场景验证
- **优先级**: P2（低）

## Excel输出格式

### 列说明

| 列名 | 说明 | 示例 |
|------|------|------|
| 用例编号 | 唯一标识 | TC0001 |
| 标题 | 测试用例标题 | FetchSelfFullUserInfo_正常调用 |
| 优先级 | P0/P1/P2 | 高/中/低 |
| 前置条件 | 执行测试前需要满足的条件 | 已登录，已创建队伍 |
| 维度 | 五维度之一 | 正常/参数异常/业务异常/权限安全/性能边界 |
| 方法+URL | 请求方法和路径 | TCP hall.FetchSelfFullUserInfo |
| 请求头 | HTTP请求头 | Content-Type: application/protobuf |
| 请求体 | 实际发送给服务器的请求参数（JSON格式） | {"target_uid": 10000263} |
| 预期状态码 | 期望的响应状态码 | 200/400/500 |
| 服务器返回 | 服务器返回的完整响应（JSON格式） | {"success": true, "response": {...}, "error_code": 200} |
| 状态 | 测试通过/不通过标记 | 通过/不通过（带颜色标识） |
| JSONPath断言 | JSONPath表达式 | $.success == true |
| 数据库校验 | 数据库验证说明 | 数据库中存在新记录 |
| 备注 | 其他说明 | 正常业务流程验证 |

### 颜色标识

- **优先级**:
  - P0（高）: 红色背景
  - P1（中）: 橙色背景
  - P2（低）: 黄色背景

- **维度**:
  - 正常: 绿色背景
  - 参数异常: 红色背景
  - 业务异常: 黄色背景
  - 权限安全: 红色背景
  - 性能边界: 蓝色背景

## 使用方法

### 1. 生成测试用例Excel

```bash
python3 main.py --generate-cases
```

### 2. 输出文件

生成的Excel文件会保存到两个位置：
- `reports/test_cases_complete.xlsx` - 报告目录
- `test_cases/test_cases_complete.xlsx` - 测试用例目录（便于管理）

### 3. 文件结构

- 每个服务一个Sheet（如HALL、ROOM、SOCIAL）
- 每个接口包含多个测试用例（正例+反例）
- 按维度分组，便于查看

## 请求体示例

### 正例JSON

```json
{
  "target_uid": 10000263,
  "nickname": "TestName_123"
}
```

### 反例JSON（5条高频）

#### 1. 必填参数缺失
```json
{
  "nickname": "TestName_123"
}
```
（缺少target_uid）

#### 2. 参数类型错误
```json
{
  "target_uid": "wrong_type_string",
  "nickname": "TestName_123"
}
```

#### 3. 参数值为空
```json
{
  "target_uid": 0,
  "nickname": ""
}
```

#### 4. 参数值超出范围
```json
{
  "target_uid": 999999999,
  "nickname": "A" * 10000
}
```

#### 5. 参数格式错误
```json
{
  "target_uid": -1,
  "nickname": "invalid_format_@#$%"
}
```

## JSONPath断言说明

### 常用断言

- **成功断言**: `$.success == true && $.error_code == 200`
- **失败断言**: `$.success == false && $.error_code != 200`
- **错误码断言**: `$.error_code == 404`
- **错误信息断言**: `$.error_message contains "not exist"`

### JSONPath语法

- `$`: 根节点
- `$.field`: 访问字段
- `$.array[0]`: 访问数组元素
- `$.field1.field2`: 访问嵌套字段
- `==`, `!=`, `contains`: 比较操作符

## 数据库校验说明

### 常见校验

- **创建操作**: "数据库中存在新记录"
- **更新操作**: "数据库记录已更新"
- **删除操作**: "数据库记录已删除"
- **查询操作**: "数据库状态正常"
- **失败场景**: "数据未变更"

## 扩展说明

### 自定义业务异常场景

可以在 `_get_business_abnormal_scenarios` 方法中添加特定接口的业务异常场景：

```python
def _get_business_abnormal_scenarios(self, service_name: str, method_name: str) -> List[Dict]:
    scenarios = []
    
    # 添加自定义场景
    if service_name == 'hall' and method_name == 'UpdateNickname':
        scenarios.append({
            'name': '昵称已存在',
            'request_body': {'nickname': 'ExistingName'},
            'expected_status': '400',
            'jsonpath': '$.error_message contains "nickname exists"',
            'db_check': '数据未变更',
            'remark': '昵称重复场景'
        })
    
    return scenarios
```

### 自定义请求体生成

可以在 `_generate_normal_value` 方法中添加特定字段的值生成逻辑。

## 注意事项

1. **请求体格式**: 所有请求体都是JSON格式，实际调用时会转换为protobuf
2. **状态码**: TCP协议使用错误码，不是HTTP状态码，但Excel中统一用状态码表示
3. **断言**: JSONPath断言需要根据实际响应结构调整
4. **数据库校验**: 需要根据实际数据库结构编写SQL验证

## 最佳实践

1. **审查生成的用例**: 自动生成的用例需要人工审查和调整
2. **补充业务场景**: 根据实际业务逻辑补充特定场景
3. **更新断言**: 根据实际响应结构更新JSONPath断言
4. **验证数据库**: 编写实际的SQL语句验证数据库状态

